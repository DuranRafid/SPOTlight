#' If you wanna test the performance of your model on synthetic generated test spots you can use this function to benchmark and get a sense of the model's performance.
#'
#' @param test_spots_metadata Object of class matrix with the predicted topic probability distributions for each spot. Output from the lda_prediction function.
#' @param spot_composition_mtrx list obtained from the function syn_spot_comb_topic_fun.R. The 1st element is a matrix with topic profiles of all the synthetic spots generated, the 2nd element is the composition of each synthetic spot.
#' @return This function returns a list with TP, TN, FP, FN and the Jensen-Shannon Divergence index.
#' @export
#' @examples
#'

test_synthetic_performance <- function(test_spots_metadata_mtrx, spot_composition_mtrx) {
  # Check variables
  if (!is.matrix(test_spots_metadata_mtrx)) stop("ERROR: test_spots_metadata_mtrx must be a matrix object!")
  if (!is.matrix(spot_composition_mtrx)) stop("ERROR: spot_composition_mtrx the deconvolution matrix with the predicted spot compositions.")

  #load required packages
  suppressMessages(require(philentropy))

  ##### Get TRUE JSD between real-predicted proportions #####
  true_jsd_mtrx <- matrix(nrow = nrow(test_spots_metadata_mtrx), ncol = 1)
  tp <- 0; tn <- 0; fp <- 0; fn <- 0
  for (i in seq_len(nrow(test_spots_metadata_mtrx))) {

    # Make sure no rows in test_spots_metadat a_mtrx is full of 0s
    if(sum(test_spots_metadata_mtrx[i, ] == 0) == ncol(test_spots_metadata_mtrx)) {
      stop(sprintf("Row %s of test_spots_metadata_mtrx is all 0, please remove the row in test_spots_metadata_mtrx & spot_composition_mtrx", i))
    }

    # Create matrix to feed to JSD
    x <- rbind("truth" = test_spots_metadata_mtrx[i, ],
               "pred" = spot_composition_mtrx[i, ])

    # Calculate JSD and save it in true_JSD_mtrx
    true_jsd_mtrx[i, 1] <- suppressMessages(JSD(x = x, unit = "log2",
                                               est.prob = "empirical"))

    #### Calculate TP-TN-FP-FN ####
    for (index in c(seq_len(ncol(test_spots_metadata_mtrx)))) {
      if (sum(x[1, index]) > 0 & sum(x[2, index]) > 0) {
        tp <- tp + 1
      } else if (sum(x[1, index]) == 0 & sum(x[2, index]) == 0) {
        tn <- tn + 1
      } else if (sum(x[1, index]) > 0 & sum(x[2, index]) == 0) {
        fn <- fn + 1
      } else if (sum(x[1, index]) == 0 & sum(x[2, index]) > 0) {
        fp <- fp + 1
      }
    }; rm(index)

  }; rm(i)

  #### Performance metrics ####
  accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
  sensitivity <- round(tp / (tp + fp), 2)
  specificity <- round(tn / (tn + fn), 2)
  precision <- round(tp / (tp + fp), 2)
  recall <- round(tp / (tp + fn), 2)
  F1 <- round(2 * ((precision * recall) / (precision + recall)), 2)

  quants_jsd <- round(quantile(matrixStats::rowMins(true_jsd_mtrx,
                                                    na.rm = TRUE),
                               c(0.25, 0.5, 0.75)), 5)

  cat(sprintf("The following summary statistics are obtained:
              Accuracy: %s,
              Sensitivity: %s,
              Specificity: %s,
              precision: %s,
              recall: %s,
              F1 score: %s,
              JSD quantiles: %s[%s-%s]",
              accuracy, sensitivity, specificity, precision, recall, F1,
              quants_jsd[[2]], quants_jsd[[1]], quants_jsd[[3]]), sep = "\n")

  cat("raw statistics are returned in the list - TP, TN, FP, FN, JSD quantiles",
      sep = "\n")
  return(list(TP = tp, TN = tn, FP = fp, FN = fn, JSD = quants_jsd))
}
